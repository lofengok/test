# test
## 杂记
### 零散知识总结
#### 1、ReentrantLock的实现原理 
  ReentrantLock是一个JUC包下的类，在API层面提供了锁机制，是一个可重入的排它锁（注1），
支持公平锁和非公平锁（注2）。提供了阻塞竞争锁和非阻塞竞争锁的两种方法lock()和tryLock()，配合try/finally语句块使用。 
  
  是一种自旋锁，通过互斥变量state属性的CAS（注3）实现锁资源的竞争。
核心是AQS（注4），AQS的底层是维护了一个双向链表FIFO，当锁资源释放时，唤醒链表头部线程。

  当是公平锁时，竞争线程会加入到这个双向链表的队尾，排队竞争。  
  而当是非公平锁时，都会先抢占一次资源，如果竞争失败，则加入队列。

- 注1：可重入锁  
  获得锁的线程在释放锁之前再次去竞争同一把锁的时候，不需要加锁就可以直接访问资源。


- 注2：公平锁和非公平锁  
**公平锁**  
  竞争线程FIFO。  
  `优点：`所有的线程都能得到资源，不会饿死在队列中。适合大任务  
  `缺点：`吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大  
**非公平锁**  
  都会先尝试竞争一次锁资源，获取不到再进入队列，否则直接获取到锁。  
  `优点：`  
  可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。  
  `缺点：`  
  可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁  
  

- 注3：CAS  
  compare and swap，是一种很出名的无锁的算法，不使用锁机制实现线程间的同步，线程是不会被阻塞的，所以又称为非阻塞同步。  
  当且仅当内存中的变量的值等于预期值的值时，才用新值去更新内存中的变量值，否则不会执行任何操作，比较和替换是一个原子（注5）操作。  
  一般情况下是一个自旋操作，即不断重试无需进入内核阻塞态，避免上下文切换带来的资源消耗。
  
  `缺点：`  
  高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源。  


- 注4：AQS  
  AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，是⼀个⽤来构建锁和同步器的框架。  
  使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，
  如：基于AQS实现的lock（注6）, CountDownLatch（注7）、CyclicBarrier（注9）、Semaphore（注10）。
  AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH（虚拟的双向队列）队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。


- 注5：原子性  
  功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile（注11）关键字来保证线程的安全。  
  当涉及到多个变量的时候CAS无能为力。  
  除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能借助atomic包下的原子类实现，灵活性受到了限制。


- 注6：lock  
  是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作。  


- 注7：CountDownLatch  
  通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。具体可以使用countDownLatch.await()来等待结果。多用于多线程信息汇总。


- 注8：CompletableFuture  
  通过设置参数，可以完成CountDownLatch同样的多平台响应问题，但是可以针对其中部分返回结果做更加灵活的展示。


- 注9：CyclicBarrier  
  字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。可以用于批量发送消息队列信息、异步限流。


- 注10：Semaphore  
  信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。SpringHystrix限流的思想。  


- 注11：volatile  
  `作用：`  
  1、保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。  
  2、禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致

  `底层实现：`  
  观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。  
  lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  
  1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；  
  2）它会强制将对缓存的修改操作立即写入主存；  
  3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

  `单例模式中volatile的作用：`  
  防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。


#### 2、Synchronized原理
  synchronized锁住的资源只有两类：一个是对象，一个是类。  
  synchronized申请锁、上锁、释放锁都与对象头有关。  
  对象头主要结构是由Mark Word 组成，其中Mark Word存储对象的hashCode、锁信息或分代年龄或GC标志等信息。  
  锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，
  新增了两种状态，总共就是四个状态：无锁状态、偏向锁、轻量级锁、重量级锁，其中无锁就是一种状态了。  
  锁的类型和状态在对象头Mark Word中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的Mark Word数据。  
  同步代码块是利用 monitorEnter 和 monitorExit 指令实现的，而同步方法则是利用 flags 实现的。  

#### 3、ReentrantLock和Synchronized的区别
1、Synchronized是Java关键字；ReentrantLock是API层面的。  
2、Synchronized无法中断，只能等到执行完成或抛异常终止；而ReentrantLock可响应中断。 
3、Synchronized是非公平锁，自由竞争；ReentrantLock默认非公平锁，也可设置成公平锁。
4、Synchronized实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、重量级锁；而ReentrantLock通过CAS自旋。

### 一、分布式事务
#### 1、XA协议
基于开源商业数据库的本身能力，如Oracle、DB2支持XA协议。
- 优点  
对业务代码无侵入，不需要投入额外开发工作量，直接使用。
- 缺点  
性能较差。
- 适用场景  
存量系统，即无法改造已有的业务代码。

#### 2、2PC
两阶段提交。  
第一阶段是预提交，各节点写入undo日志。  
第二阶段是最终提交，都执行成功提交，否则回滚所有节点。
- 优点  
XA协议的一种实现流程，不需要投入额外开发工作量，直接使用。
- 缺点  
性能较差。第一阶段就需要写日志，任意节点出问题，都需回滚，成本较大。
- 适用场景  
  存量系统，即无法改造已有的业务代码。
  
#### 3、3PC
三阶段提交。  
第一阶段是检查资源。  
第二阶段是预提交。  
第三阶段是最终提交。
- 优点  
  XA协议的一种实现流程，不需要投入额外开发工作量，直接使用。  
  相比2PC，第一段只需要检查节点网络和资源是否政策，无实际数据写入，可提前发现问题节点，回滚成本小； 
  第二阶段过程中，优化了协调逻辑，当某节点超时响应时，可以自动回滚本次事务。
- 缺点  
  大多数情况下，数据库是一个持续工作的中间件，几乎很少出现某个节点网络或资源故障，所以针对第一阶段的检查资源，大多情况下都是浪费一次交互。
  
#### 4、TCC
try、confirm、cancel。开源中间件如Seata以提供该方式。
- 优点  
轻量级框架以提供。
- 缺点  
侵入业务代码，需要改造实现回滚。
- 适用场景  
  严格要求不能错的，持续开发中的系统，借助Seata组件快速实现。
  
#### 5、Saga
长事务解决方案
- 优点  
  。
- 缺点  
  。
- 适用场景  
  适用于流程长、流程多、调用第三方业务。

#### 6、最终一致性
能容忍短时间内的数据不一致，有中间态，但最终会达到一致。一般会借助MQ组件实现。  
比如阿里的 RocketMQ 就支持消息事务（核心：双端确认，重试幂等）。  
- 优点  
  比较灵活，实现方式较多。
- 缺点  
  需要开发。不满足对数据一致性要求高的场景。
- 适用场景  
  只需数据最终一致性即可。如积分数据

#### 7、最大努力通知
基本同"最终一致性"方式。一般会借助MQ组件实现，MQ下游服务消费消息，根据配置调度通知其它服务执行，如果超过失败重试次数，需要人工介入。
- 优点  
  灵活解耦，根据业务场景具体实现。
- 缺点  
  
- 适用场景  
  基本同"最终一致性"方式。如果分布式场景允许不一致，可以使用最大努力通知方案。
  
